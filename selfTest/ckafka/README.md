当前公司的kafka版本为: confluent  kafka_2.15-5.3.1
==============================================

生产者默认配置  
>   enable.idempotence = true  
>   当设置为‘true’，生产者将确保每个消息正好一次复制写入到stream。  
    如果‘false’，由于broker故障，生产者重试。即，可以在流中写入重试的消息。此设置默认是‘false’。  
    请注意，启用幂等式需要将max.in.flight.requests.per.connection设置为1，重试次数不能为零。  
    另外acks必须设置为“全部”。如果这些值保持默认值，我们将覆盖默认值。  
    如果这些值设置为与幂等生成器不兼容的值，则将抛出一个ConfigException异常。  
    如果这些值设置为与幂等生成器不兼容的值，则将抛出一个ConfigException异常。  
    
>   compression.type = "lz4"  
    数据压缩的类型。默认为空（就是不压缩）。  
    有效的值有 none，gzip，snappy, 或 lz4。  
    压缩全部的数据批，因此批的效果也将影响压缩的比率（更多的批次意味着更好的压缩）。  
    
>   topic.request.required.acks = -1  
>   生产者需要leader确认请求完成之前接收的应答数。此配置控制了发送消息的耐用性，支持以下配置：  
     acks=0 如果设置为0，那么生产者将不等待任何消息确认。  
         消息将立刻添加到socket缓冲区并考虑发送。在这种情况下不能保障消息被服务器接收到。  
         并且重试机制不会生效（因为客户端不知道故障了没有）。每个消息返回的offset始终设置为-1。  
     acks=1 这意味着leader写入消息到本地日志就立即响应，而不等待所有follower应答。  
         在这种情况下，如果响应消息之后但follower还未复制之前leader立即故障，那么消息将会丢失。  
     acks=all 这意味着leader将等待所有副本同步后应答消息。  
         此配置保障消息不会丢失（只要至少有一个同步的副本或者）。  
         这是最强壮的可用性保障。等价于acks=-1。  

>   request.timeout.ms = 1000  
>   该配置控制客户端等待请求响应的最长时间。  
    如果在超时之前未收到响应，客户端将在必要时重新发送请求，如果重试耗尽，则该请求将失败。  
    这应该大于 replica.lag.time.max.ms，以减少由于不必要的生产者重试引起的消息重复的可能性。  

>   delivery.timeout.ms = 1000  
>   调用send()返回后报告成功或失败的时间上限。  
    这限制了消息在发送前被延迟的总时间，等待broker确认的时间（如果期望的话），以及允许重试发送失败的时间。  
    如果遇到不可恢复的错误，重试次数已经用尽，或者消息被添加到一个达到较早发送到期期限的批次中，  
    生产者可能会报告未能在这个配置之前发送记录。  
    这个配置的值应该大于或等于 request.timeout.ms 和 linger.ms 之和。  
	
>   更多生产者的详细配置项可查看: https://www.orchome.com/511  